<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weaving Answers - Interactive Data Textile</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #9d4479;
            --secondary: #b950b2;
            --accent1: #a37bb9;
            --accent2: #af306e;
            --dark1: #62022f;
            --dark2: #500c32;
            --mid: #aa6391;
            --light: #e9bed9;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: linear-gradient(135deg, var(--dark2) 0%, var(--dark1) 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(233, 190, 217, 0.05);
            border: 1px solid rgba(233, 190, 217, 0.15);
            border-radius: 2px;
        }

        h1 {
            font-size: 3em;
            font-weight: 300;
            letter-spacing: 0.05em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--secondary), var(--accent2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-family: 'Space Mono', monospace;
            font-size: 0.85em;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            opacity: 0.6;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 40px;
            margin-bottom: 40px;
        }

        .question-panel {
            background: rgba(233, 190, 217, 0.08);
            padding: 30px;
            border: 1px solid rgba(233, 190, 217, 0.2);
            border-radius: 2px;
        }

        .question-label {
            font-family: 'Space Mono', monospace;
            font-size: 0.75em;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            opacity: 0.5;
            margin-bottom: 15px;
        }

        #currentQuestion {
            font-size: 1.8em;
            line-height: 1.4;
            margin-bottom: 30px;
            font-weight: 300;
        }

        #answerInput {
            width: 100%;
            padding: 20px;
            font-family: 'Crimson Pro', serif;
            font-size: 1.2em;
            background: rgba(233, 190, 217, 0.1);
            border: 2px solid rgba(233, 190, 217, 0.3);
            color: var(--light);
            border-radius: 2px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        #answerInput:focus {
            outline: none;
            border-color: var(--secondary);
            background: rgba(233, 190, 217, 0.15);
        }

        #submitAnswer {
            width: 100%;
            padding: 18px;
            font-family: 'Space Mono', monospace;
            font-size: 0.9em;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            background: linear-gradient(135deg, var(--primary), var(--accent2));
            border: none;
            color: var(--light);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.3s ease;
            font-weight: 700;
        }

        #submitAnswer:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(185, 80, 178, 0.4);
        }

        #submitAnswer:active {
            transform: translateY(0);
        }

        #exportButton {
            width: 100%;
            padding: 18px;
            font-family: 'Space Mono', monospace;
            font-size: 0.9em;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            background: linear-gradient(135deg, var(--accent1), var(--mid));
            border: none;
            color: var(--light);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.3s ease;
            font-weight: 700;
            margin-top: 15px;
        }

        #exportButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(163, 123, 185, 0.4);
        }

        #exportButton:active {
            transform: translateY(0);
        }

        #exportTiledButton {
            width: 100%;
            padding: 18px;
            font-family: 'Space Mono', monospace;
            font-size: 0.9em;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            background: linear-gradient(135deg, var(--mid), var(--primary));
            border: none;
            color: var(--light);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.3s ease;
            font-weight: 700;
            margin-top: 15px;
        }

        #exportTiledButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(170, 99, 145, 0.4);
        }

        #exportTiledButton:active {
            transform: translateY(0);
        }

        #adminResetButton {
            width: 100%;
            padding: 12px;
            font-family: 'Space Mono', monospace;
            font-size: 0.75em;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            background: rgba(98, 2, 47, 0.5);
            border: 1px solid rgba(233, 190, 217, 0.2);
            color: rgba(233, 190, 217, 0.6);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.3s ease;
            font-weight: 400;
            margin-top: 30px;
        }

        #adminResetButton:hover {
            background: rgba(98, 2, 47, 0.7);
            color: var(--light);
            border-color: var(--accent2);
        }

        #adminResetButton:active {
            transform: scale(0.98);
        }

        .stats {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 1px solid rgba(244, 232, 216, 0.1);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-family: 'Space Mono', monospace;
            font-size: 0.85em;
        }

        .stat-label {
            opacity: 0.6;
            letter-spacing: 0.1em;
        }

        .stat-value {
            color: var(--secondary);
            font-weight: 700;
        }

        .weaving-canvas {
            background: rgba(233, 190, 217, 0.03);
            border: 1px solid rgba(233, 190, 217, 0.2);
            border-radius: 2px;
            padding: 20px;
            min-height: 600px;
            position: relative;
            overflow: hidden;
        }

        .pattern-title {
            font-family: 'Space Mono', monospace;
            font-size: 0.75em;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            opacity: 0.5;
            margin-bottom: 20px;
            text-align: center;
        }

        #weavingPattern {
            position: relative;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            min-height: 600px;
            display: grid;
            grid-template-columns: repeat(auto-fill, 40px);
            grid-auto-rows: 40px;
            gap: 0;
            background: rgba(233, 190, 217, 0.08);
        }

        .weave-tile {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .weave-tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            image-rendering: high-quality;
        }

        .tile-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Crimson Pro', serif;
            font-size: 0.5em;
            color: var(--weft);
            text-align: center;
            padding: 2px;
            background: none;
            word-break: break-word;
            line-height: 1.1;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 1),
                         0 0 8px rgba(0, 0, 0, 0.8),
                         1px 1px 0 rgba(0, 0, 0, 1),
                         -1px -1px 0 rgba(0, 0, 0, 1),
                         1px -1px 0 rgba(0, 0, 0, 1),
                         -1px 1px 0 rgba(0, 0, 0, 1);
            opacity: 1;
        }

        .legend {
            margin-top: 30px;
            padding: 20px;
            background: rgba(233, 190, 217, 0.05);
            border: 1px solid rgba(233, 190, 217, 0.15);
            border-radius: 2px;
        }

        .legend-title {
            font-family: 'Space Mono', monospace;
            font-size: 0.75em;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            opacity: 0.5;
            margin-bottom: 15px;
        }

        .legend-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .legend-item {
            font-size: 0.9em;
            line-height: 1.6;
        }

        .diversity-indicator {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, 
                rgba(185, 80, 178, 0.15), 
                rgba(175, 48, 110, 0.15));
            border-left: 3px solid var(--secondary);
            border-radius: 2px;
        }

        .diversity-label {
            font-family: 'Space Mono', monospace;
            font-size: 0.75em;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            opacity: 0.7;
            margin-bottom: 8px;
        }

        .diversity-value {
            font-size: 1.5em;
            color: var(--secondary);
            font-weight: 600;
        }

        @keyframes weaveIn {
            from {
                transform: scale(0.95);
            }
            to {
                transform: scale(1);
            }
        }

        .weave-thread.new {
            animation: weaveIn 0.3s ease-out;
        }

        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <!-- html2canvas for PNG export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <div class="container">
        <header>
            <h1>Weaving Diverse Data</h1>
            <div class="subtitle">Interactive Data Textile</div>
            <div style="margin-top: 15px; font-family: 'Space Mono', monospace; font-size: 0.8em; opacity: 0.6;">
                <span id="onlineCount">üåê Connecting...</span>
            </div>
        </header>

        <div class="main-grid">
            <div class="question-panel">
                <div class="question-label">Question</div>
                <div id="currentQuestion">Does AI make you more efficient in your work?</div>
                
                <input type="text" id="answerInput" placeholder="Type your answer here..." autocomplete="off">
                <button id="submitAnswer">Weave Data</button>
                <button id="exportButton">üì∏ Export Textile as PNG</button>
                <button id="exportTiledButton">üî≤ Export Tiled Textile (3√ó3)</button>

                <div style="margin-top: 15px;">
                    <label style="font-family: 'Space Mono', monospace; font-size: 0.75em; letter-spacing: 0.1em; opacity: 0.7; display: block; margin-bottom: 8px;">WEAVE PATTERN:</label>
                    <select id="weavePattern" style="width: 100%; padding: 12px; font-family: 'Crimson Pro', serif; font-size: 1em; background: rgba(233, 190, 217, 0.1); border: 2px solid rgba(233, 190, 217, 0.3); color: #e9bed9; border-radius: 2px;">
                        <option value="plain">Plain Weave</option>
                        <option value="twill" selected>Twill</option>
                        <option value="satin">Satin</option>
                        <option value="basket">Basket Weave</option>
                        <option value="pointed">Pointed Twill</option>
                        <option value="herringbone">Herringbone</option>
                        <option value="warp_rib">Warp Rib</option>
                        <option value="weft_rib">Weft Rib</option>
                        <option value="double">Double Cloth</option>
                    </select>
                </div>

                <div class="stats">
                    <div class="stat-item">
                        <span class="stat-label">Total Threads</span>
                        <span class="stat-value" id="totalThreads">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Unique Answers</span>
                        <span class="stat-value" id="uniqueAnswers">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Pattern Density</span>
                        <span class="stat-value" id="patternDensity">0%</span>
                    </div>
                </div>

                <div class="diversity-indicator">
                    <div class="diversity-label">Diversity Score</div>
                    <div class="diversity-value" id="diversityScore">0.00</div>
                </div>

                <button id="adminResetButton">üîí Admin Reset</button>
            </div>

            <div class="weaving-canvas">
                <div class="pattern-title">Your Collective Weave</div>
                <div id="weavingPattern"></div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-title">Pattern Guide</div>
            <div class="legend-items">
                <div class="legend-item">
                    <strong>Thread Size:</strong> Determined by answer diversity - unique answers create larger data points
                </div>
                <div class="legend-item">
                    <strong>Placement:</strong> Random images (image01.png - image100.png) form the textile base
                </div>
                <div class="legend-item">
                    <strong>Pattern Type:</strong> Adapts between jacquard, plaid, herringbone, and twill based on diversity
                </div>
                <div class="legend-item">
                    <strong>Text:</strong> Each answer is woven into the textile and visible on every thread
                </div>
            </div>
        </div>
    </div>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAv7mCzyFnVE_pvLQyZsDacdqJo387oCts",
            authDomain: "weavingdiversedata.firebaseapp.com",
            projectId: "weavingdiversedata",
            storageBucket: "weavingdiversedata.firebasestorage.app",
            messagingSenderId: "331704605325",
            appId: "1:331704605325:web:69b17c5590bc12e8c7a0c4",
            measurementId: "G-R81YTMZ608"
        };

        // Initialize Firebase
        let db, answersCollection, onlineCollection, myPresenceDoc;
        let isOnline = false;
        
        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            answersCollection = db.collection('weavingAnswers');
            onlineCollection = db.collection('weavingOnline');
            isOnline = true;
            console.log('‚úÖ Firestore connected');
        } catch (error) {
            console.log('üì¥ Running in offline mode:', error);
            isOnline = false;
        }

        // Presence tracking with Firestore
        if (isOnline) {
            // Create a unique presence document for this user
            myPresenceDoc = onlineCollection.doc();
            
            // Set presence
            myPresenceDoc.set({
                online: true,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });

            // Clean up on disconnect (using visibility API as fallback)
            const cleanup = () => {
                if (myPresenceDoc) {
                    myPresenceDoc.delete().catch(() => {});
                }
            };
            
            window.addEventListener('beforeunload', cleanup);
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) cleanup();
            });

            // Update online count
            onlineCollection.onSnapshot((snapshot) => {
                const count = snapshot.size;
                document.getElementById('onlineCount').textContent = `üë• ${count} weaving now`;
            });

            // Clean up old presence records (older than 5 minutes)
            const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
            onlineCollection.where('timestamp', '<', fiveMinutesAgo).get().then((snapshot) => {
                snapshot.forEach((doc) => doc.ref.delete());
            });
        } else {
            document.getElementById('onlineCount').textContent = 'üì¥ Offline mode';
        }

        // Configuration
        const TOTAL_IMAGES = 20;
        const questions = [
            "Does AI make you more efficient in your work?",
            "Can AI perform the tasks that you need completed in your life?",
            "Would a self-driving car help you?",
            "Does technology improve your learning?",
            "Do you feel in control of the technology you use daily?",
            "Does social media give you power or take it away?",
            "Can you customize your digital tools to fit your needs?",
            "Do algorithms serve you or manipulate you?",
            "Does automation free you or replace you?",
            "Do you trust AI to make decisions that affect your life?"
        ];

        // State
        let answers = [];
        let currentQuestionIndex = 0;
        let threadCount = 0;
        let answerImages = {}; // Store which image belongs to which answer

        // DOM Elements
        const questionEl = document.getElementById('currentQuestion');
        const answerInput = document.getElementById('answerInput');
        const submitBtn = document.getElementById('submitAnswer');
        const weavingPattern = document.getElementById('weavingPattern');
        const totalThreadsEl = document.getElementById('totalThreads');
        const uniqueAnswersEl = document.getElementById('uniqueAnswers');
        const patternDensityEl = document.getElementById('patternDensity');
        const diversityScoreEl = document.getElementById('diversityScore');

        // Listen for Firestore updates
        if (isOnline) {
            answersCollection.orderBy('timestamp', 'asc').onSnapshot((snapshot) => {
                answers = [];
                snapshot.forEach((doc) => {
                    answers.push(doc.data().answer);
                });
                updateWeaving();
            });
        }

        // Calculate diversity score (higher = more varied answers)
        function calculateDiversity() {
            if (answers.length === 0) return 0;
            
            const uniqueAnswers = new Set(answers.map(a => a.toLowerCase().trim()));
            const diversityRatio = uniqueAnswers.size / answers.length;
            
            // Bonus for length variety
            const lengths = answers.map(a => a.length);
            const avgLength = lengths.reduce((a, b) => a + b, 0) / lengths.length;
            const lengthVariance = lengths.reduce((sum, len) => sum + Math.pow(len - avgLength, 2), 0) / lengths.length;
            const lengthDiversity = Math.min(lengthVariance / 100, 1);
            
            return (diversityRatio * 0.7 + lengthDiversity * 0.3).toFixed(2);
        }

        // Get weaving pattern type based on diversity (for automatic selection)
        function getPatternType(diversity) {
            if (diversity > 0.8) return 'pointed';
            if (diversity > 0.6) return 'twill';
            if (diversity > 0.4) return 'basket';
            return 'plain';
        }

        // Get tile size based on number of answers (more answers = smaller tiles)
        function getTileSize(answerCount) {
            if (answerCount < 10) return 60;
            if (answerCount < 25) return 50;
            if (answerCount < 50) return 40;
            if (answerCount < 100) return 35;
            return 30;
        }

        // Calculate which answer to use for this tile based on weave pattern
        function getPatternIndex(x, y, weaveStyle, totalAnswers) {
            if (totalAnswers === 0) return 0;
            
            let patternIndex;
            const cols = Math.floor(900 / 60); // Match the cols in updateWeaving (updated to 60)

            switch (weaveStyle) {
                case 'plain':
                    // Checkerboard - distribute answers across diagonal lines
                    patternIndex = Math.floor((x + y) / 2) % totalAnswers;
                    break;

                case 'twill':
                    // Diagonal lines - each diagonal stripe is one answer
                    patternIndex = Math.floor((x + y) / 2) % totalAnswers;
                    break;

                case 'satin':
                    // Satin weave - scattered but all answers appear
                    patternIndex = Math.floor((x * 3 + y * 5) / 3) % totalAnswers;
                    break;

                case 'basket':
                    // 2x2 basket weave blocks - distribute across blocks
                    const blockX = Math.floor(x / 2);
                    const blockY = Math.floor(y / 2);
                    patternIndex = (blockX + blockY) % totalAnswers;
                    break;

                case 'pointed':
                    // Pointed twill - zigzag chevron
                    const halfWidth = 4;
                    const zigzag = (y % (halfWidth * 2)) < halfWidth ? 
                        Math.floor((x + y) / 2) % totalAnswers : 
                        Math.floor((x - y + 100) / 2) % totalAnswers;
                    patternIndex = Math.abs(zigzag) % totalAnswers;
                    break;

                case 'herringbone':
                    // Herringbone - diagonal changes direction periodically
                    const blockSize = 6;
                    const direction = Math.floor(y / blockSize) % 2 === 0 ? 1 : -1;
                    patternIndex = Math.floor((x + direction * y) / 2) % totalAnswers;
                    break;

                case 'warp_rib':
                    // Vertical ribs - distribute answers across columns
                    // Divide columns into equal groups for each answer
                    const colsPerAnswer = Math.max(1, Math.floor(cols / totalAnswers));
                    patternIndex = Math.floor(x / colsPerAnswer) % totalAnswers;
                    break;

                case 'weft_rib':
                    // Horizontal ribs - distribute answers across rows
                    const rows = 20; // Updated to match new row count
                    const rowsPerAnswer = Math.max(1, Math.floor(rows / totalAnswers));
                    patternIndex = Math.floor(y / rowsPerAnswer) % totalAnswers;
                    break;

                case 'double':
                    // Double cloth - larger blocks
                    const dblBlockX = Math.floor(x / 3);
                    const dblBlockY = Math.floor(y / 3);
                    patternIndex = (dblBlockX + dblBlockY) % totalAnswers;
                    break;

                default:
                    patternIndex = Math.floor((x + y) / 2) % totalAnswers;
            }

            // Ensure we always return a valid index
            return Math.abs(Math.floor(patternIndex)) % totalAnswers;
        }

        // Update the weaving pattern
        function updateWeaving() {
            const diversity = calculateDiversity();
            const weaveSelector = document.getElementById('weavePattern');
            const weaveStyle = weaveSelector ? weaveSelector.value : 'twill';
            
            // Clear and rebuild
            weavingPattern.innerHTML = '';
            
            if (answers.length === 0) {
                weavingPattern.style.minHeight = '400px';
                return;
            }

            // Assign images to answers if not already assigned
            answers.forEach(answer => {
                if (!answerImages[answer]) {
                    answerImages[answer] = getRandomImage();
                }
            });

            // Calculate grid dimensions
            const tileSize = 60; // Increased from 40 to 60 (50% bigger)
            const cols = Math.floor(900 / tileSize);
            const rows = 20; // Increased from 15 to 20 (more rows)
            const totalTiles = cols * rows;
            
            // Set grid template
            weavingPattern.style.gridTemplateColumns = `repeat(${cols}, ${tileSize}px)`;
            weavingPattern.style.gridAutoRows = `${tileSize}px`;
            weavingPattern.style.minHeight = (rows * tileSize) + 'px';
            
            // Create an array to store which answer goes in each position
            const tileAssignments = new Array(totalTiles);
            
            // STEP 1: Ensure every answer appears at least once
            // Place each answer in a position determined by the pattern
            const answerPositions = [];
            for (let i = 0; i < answers.length; i++) {
                // Find a good position for this answer based on the pattern
                // Spread them out evenly across the grid
                const idealPosition = Math.floor((i * totalTiles) / answers.length);
                answerPositions.push(idealPosition);
                tileAssignments[idealPosition] = i;
            }
            
            // STEP 2: Fill remaining positions with pattern
            for (let i = 0; i < totalTiles; i++) {
                // Skip if already assigned in step 1
                if (tileAssignments[i] !== undefined) continue;
                
                const x = i % cols;
                const y = Math.floor(i / cols);
                
                // Use pattern to determine which answer
                const answerIndex = getPatternIndex(x, y, weaveStyle, answers.length);
                tileAssignments[i] = answerIndex;
            }
            
            // STEP 3: Create tiles based on assignments
            for (let i = 0; i < totalTiles; i++) {
                const answerIndex = tileAssignments[i];
                const answer = answers[answerIndex];
                
                if (!answer) continue;
                
                // Create tile
                const tile = document.createElement('div');
                tile.className = 'weave-tile';
                
                // Add image - consistent image for this answer
                const img = document.createElement('img');
                img.src = answerImages[answer];
                img.alt = '';
                img.loading = 'eager';
                tile.appendChild(img);
                
                // Add answer overlay
                const overlay = document.createElement('div');
                overlay.className = 'tile-overlay';
                overlay.textContent = answer;
                tile.appendChild(overlay);
                
                weavingPattern.appendChild(tile);
            }
            
            // Update stats
            totalThreadsEl.textContent = answers.length;
            uniqueAnswersEl.textContent = new Set(answers.map(a => a.toLowerCase().trim())).size;
            patternDensityEl.textContent = Math.min(100, Math.round(answers.length * 2.5)) + '%';
            diversityScoreEl.textContent = diversity;
        }

        // Get random image
        function getRandomImage() {
            const imageNum = Math.floor(Math.random() * TOTAL_IMAGES) + 1;
            const paddedNum = String(imageNum).padStart(2, '0');
            return `images/image${paddedNum}.png`;
        }

        // Calculate thread size based on answer uniqueness
        function getThreadSize(answer) {
            const normalizedAnswer = answer.toLowerCase().trim();
            const occurrences = answers.filter(a => a.toLowerCase().trim() === normalizedAnswer).length;
            
            // More unique = larger thread
            if (occurrences === 1) return 1.5; // Very unique
            if (occurrences === 2) return 1.2;
            if (occurrences === 3) return 1.0;
            return 0.8; // Common answer = smaller
        }


        // Submit answer
        function submitAnswer() {
            const answer = answerInput.value.trim();
            
            if (!answer) {
                answerInput.style.borderColor = 'var(--accent2)';
                setTimeout(() => {
                    answerInput.style.borderColor = 'rgba(233, 190, 217, 0.3)';
                }, 300);
                return;
            }
            
            if (isOnline) {
                // Add to Firestore
                answersCollection.add({
                    answer: answer,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                }).then(() => {
                    console.log('Answer added to Firestore');
                }).catch((error) => {
                    console.error('Error adding answer:', error);
                });
            } else {
                // Add locally
                answers.push(answer);
                updateWeaving();
            }
            
            threadCount++;
            
            // Clear input
            answerInput.value = '';
            answerInput.focus();
            
            // Cycle questions
            currentQuestionIndex = (currentQuestionIndex + 1) % questions.length;
            questionEl.textContent = questions[currentQuestionIndex];
        }

        // Admin reset function with password
        function adminReset() {
            const password = prompt('Enter admin password:');
            
            if (password === 'admin123') {
                const confirmReset = confirm('Are you sure you want to delete ALL data? This cannot be undone.');
                
                if (confirmReset) {
                    if (isOnline) {
                        // Delete all documents in Firestore
                        answersCollection.get().then((querySnapshot) => {
                            const batch = firebase.firestore().batch();
                            querySnapshot.forEach((doc) => {
                                batch.delete(doc.ref);
                            });
                            return batch.commit();
                        }).then(() => {
                            alert('All data has been reset.');
                            answers = [];
                            updateWeaving();
                        }).catch((error) => {
                            console.error('Error resetting data:', error);
                            alert('Error resetting data. Check console.');
                        });
                    } else {
                        // Reset locally
                        answers = [];
                        updateWeaving();
                        alert('Local data has been reset.');
                    }
                }
            } else if (password !== null) {
                alert('Incorrect password.');
            }
        }

        // Export textile as PNG
        async function exportTextile() {
            const exportBtn = document.getElementById('exportButton');
            const originalText = exportBtn.textContent;
            
            try {
                exportBtn.textContent = '‚è≥ Capturing textile...';
                exportBtn.disabled = true;
                
                // Wait a moment for any images to finish loading
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const weavingCanvas = document.querySelector('.weaving-canvas');
                
                const canvas = await html2canvas(weavingCanvas, {
                    backgroundColor: '#500c32', // Dark purple from color scheme
                    scale: 6, // Even higher quality (6x resolution)
                    logging: true,
                    useCORS: true,
                    allowTaint: true,
                    foreignObjectRendering: false,
                    imageTimeout: 20000,
                    removeContainer: true,
                    width: weavingCanvas.offsetWidth,
                    height: weavingCanvas.offsetHeight,
                    windowWidth: weavingCanvas.scrollWidth,
                    windowHeight: weavingCanvas.scrollHeight,
                    onclone: function(clonedDoc) {
                        // Force high quality rendering in the clone
                        const clonedCanvas = clonedDoc.querySelector('.weaving-canvas');
                        if (clonedCanvas) {
                            clonedCanvas.style.imageRendering = 'high-quality';
                            clonedCanvas.style.backgroundColor = '#500c32'; // Match dark purple
                        }
                        // Force all images to render at full quality
                        const images = clonedDoc.querySelectorAll('.weave-thread');
                        images.forEach(img => {
                            img.style.imageRendering = 'high-quality';
                        });
                    }
                });
                
                // Convert to PNG with maximum quality
                canvas.toBlob((blob) => {
                    if (!blob) {
                        throw new Error('Failed to create image blob');
                    }
                    
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    link.download = `weaving-textile-${timestamp}.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    exportBtn.textContent = '‚úÖ Exported!';
                    setTimeout(() => {
                        exportBtn.textContent = originalText;
                        exportBtn.disabled = false;
                    }, 2000);
                }, 'image/png', 1.0); // Quality set to maximum (1.0)
                
            } catch (error) {
                console.error('Export error details:', error);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                
                exportBtn.textContent = '‚ùå Export failed - check console';
                setTimeout(() => {
                    exportBtn.textContent = originalText;
                    exportBtn.disabled = false;
                }, 3000);
                
                // Show user-friendly error
                alert('Export failed. Common fixes:\n\n1. Make sure all images are in the images/ folder\n2. Run from a web server (not file://)\n3. Check browser console (F12) for details');
            }
        }

        // Export tiled textile (3x3 grid of the weaving)
        async function exportTiledTextile() {
            const exportBtn = document.getElementById('exportTiledButton');
            const originalText = exportBtn.textContent;
            
            try {
                exportBtn.textContent = '‚è≥ Creating tiled version...';
                exportBtn.disabled = true;
                
                // Wait a moment for any images to finish loading
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const weavingCanvas = document.querySelector('.weaving-canvas');
                
                // First capture the single weaving
                const singleCanvas = await html2canvas(weavingCanvas, {
                    backgroundColor: '#500c32',
                    scale: 4, // Slightly lower scale since we're making it bigger
                    logging: false,
                    useCORS: true,
                    allowTaint: true,
                    foreignObjectRendering: false,
                    imageTimeout: 20000,
                    removeContainer: true,
                    width: weavingCanvas.offsetWidth,
                    height: weavingCanvas.offsetHeight,
                    windowWidth: weavingCanvas.scrollWidth,
                    windowHeight: weavingCanvas.scrollHeight
                });
                
                // Create a larger canvas for the 3x3 tiled version
                const tilesX = 3;
                const tilesY = 3;
                const tiledCanvas = document.createElement('canvas');
                tiledCanvas.width = singleCanvas.width * tilesX;
                tiledCanvas.height = singleCanvas.height * tilesY;
                const ctx = tiledCanvas.getContext('2d');
                
                // Fill background
                ctx.fillStyle = '#500c32';
                ctx.fillRect(0, 0, tiledCanvas.width, tiledCanvas.height);
                
                // Tile the weaving in a 3x3 grid
                for (let y = 0; y < tilesY; y++) {
                    for (let x = 0; x < tilesX; x++) {
                        ctx.drawImage(
                            singleCanvas,
                            x * singleCanvas.width,
                            y * singleCanvas.height
                        );
                    }
                }
                
                // Convert to PNG and download
                tiledCanvas.toBlob((blob) => {
                    if (!blob) {
                        throw new Error('Failed to create tiled image blob');
                    }
                    
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    link.download = `weaving-textile-tiled-${timestamp}.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    exportBtn.textContent = '‚úÖ Tiled Export Complete!';
                    setTimeout(() => {
                        exportBtn.textContent = originalText;
                        exportBtn.disabled = false;
                    }, 2000);
                }, 'image/png', 1.0);
                
            } catch (error) {
                console.error('Tiled export error:', error);
                
                exportBtn.textContent = '‚ùå Export failed';
                setTimeout(() => {
                    exportBtn.textContent = originalText;
                    exportBtn.disabled = false;
                }, 3000);
                
                alert('Tiled export failed. Check console for details.');
            }
        }

        // Event listeners
        submitBtn.addEventListener('click', submitAnswer);
        document.getElementById('exportButton').addEventListener('click', exportTextile);
        document.getElementById('exportTiledButton').addEventListener('click', exportTiledTextile);
        document.getElementById('adminResetButton').addEventListener('click', adminReset);
        document.getElementById('weavePattern').addEventListener('change', () => {
            updateWeaving();
        });
        answerInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') submitAnswer();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (isOnline && myPresenceDoc) {
                myPresenceDoc.delete().catch(() => {});
            }
        });

        // Initialize
        answerInput.focus();
    </script>
</body>
</html>
